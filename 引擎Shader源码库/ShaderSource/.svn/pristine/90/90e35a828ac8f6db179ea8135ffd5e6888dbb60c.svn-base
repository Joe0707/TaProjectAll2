["pbr scene shader for DM106"]
pipeline
<
	version = "1.1.2" 
	author = "konglingjie" 
	category = "common" 
	company = "netease"
	merge = "1"
>
{
	include(shader\\including\\pbr_include_function.spzs)
	["检查AO"]
	eitheror AO_CHECK;
	macro(AO_CHECK)
	<
		default = "0"
		customizable = "1"
	>;

	["检查diffuse"]
	eitheror DIFFUSE_CHECK;
	macro(DIFFUSE_CHECK)
	<
		default = "0"
		customizable = "1"
	>;

	["检查金属度"]
	eitheror METAL_CHECK;
	macro(METAL_CHECK)
	<
		default = "0"
		customizable = "1"
	>;

	["检查粗糙度"]
	eitheror ROUGHNESS_CHECK;
	macro(ROUGHNESS_CHECK)
	<
		default = "0"
		customizable = "1"
	>;

	["是否开启Oren-nayar因子"]
	eitheror ORENNAYAR_ENABLE;
	macro(ORENNAYAR_ENABLE)
	<
		default = "1"
		customizable = "1"
	>;

	["开启法线贴图(XNORMAL_MAP_ENABLE)"]
	eitheror XNORMAL_MAP_ENABLE;
	macro(XNORMAL_MAP_ENABLE)
	<
		default = "1"
		customizable = "1"
	>;

	["开启环境反射(ENVIR_ENABLE)"]
	eitheror ENVIR_ENABLE;
	macro(ENVIR_ENABLE)
	<
		default = "1"
		customizable = "1"
	>;

	["开启自发光"]
	eitheror SELF_BLING;
	macro(SELF_BLING)
	<
		default = "0"
		customizable = "1"
	>;

	["流光特效"]
	eitheror USE_FLOWEMISS_VFX;
	macro(USE_FLOWEMISS_VFX)
	<
		customizable = "1"
		default = "0"
	>;

	["是否启用场景转置"]
	eitheror TRANS_ENABLE;
	macro(TRANS_ENABLE)
	<
		customizable = "1"
		default = "0"
	>;

	["开启力场扰动"]
	eitheror FORCE_FIELD_ENABLE;
	macro(FORCE_FIELD_ENABLE)
	<
		customizable = "1"
		default = "0"
	>;

	["开启空间撕裂"]
	eitheror FX_ENABLE;
	macro(FX_ENABLE)
	<
		customizable = "1"
		default = "0"
	>;

	["是否双阵营"]
	eitheror TWOGROUP_ENABLE;
	macro(TWOGROUP_ENABLE)
	<
		customizable = "1"
		default = "1"
	>;

	["压暗diffuse"]
	eitheror DIFFUSE_DARK;
	macro(DIFFUSE_DARK)
	<
		customizable = "1"
		default = "0"
	>;

	["风摆动动画"]
	eitheror WIND_ON;
	macro(WIND_ON)
	<
		customizable = "1"
		default = "0"
	>;
	["开启顶点动画"]
	eitheror ANIME_ENABLE;
	macro(ANIME_ENABLE)
	<
		customizable = "1"
		default = "0"
	>;

	["开启云光"]
	eitheror CLOUD_LIGHT;
	macro(CLOUD_LIGHT)
	<
		customizable = "0"
		default = "0"
	>;

	["开启法线噪点"]
	eitheror NORMAL_NOISE;
	macro(NORMAL_NOISE)
	<
		customizable = "1"
		default = "0"
	>;

	["是否开启AO"]
	eitheror OCCLUSION_ENABLE;
	macro(OCCLUSION_ENABLE)
	<
		customizable = "1"
		default = "1"
	>;

	["开启高光限制"]
	eitheror SPECULAR_LIMIT;
	macro(SPECULAR_LIMIT)
	<
		customizable = "1"
		default = "0"
	>;

	["开启LUT"]
	eitheror LUT_ENABLE;
	macro(LUT_ENABLE)
	<
		customizable = "1"
		default = "1"
	>;

    uniform mediump float4x4 envSHR
    <
        init = "(0.231358, -0.124999, 0.141454, -0.270840, -0.124999, -0.231358, -0.022605, 0.073581, 0.141454, -0.022605, -0.215790, -0.061644, -0.270840, 0.073581, -0.061644, 0.541711)"
    >;
    uniform mediump float4x4 envSHG
    <
        init = "(0.224274, -0.122513, 0.136086, -0.270001, -0.122513, -0.224274, -0.018869, 0.086609, 0.136086, -0.018869, -0.210799, -0.055277, -0.270001, 0.086609, -0.055277, 0.529594)"
    >;
    uniform mediump float4x4 envSHB
    <
        init = "(0.181635, -0.102099, 0.110363, -0.229083, -0.102099, -0.181635, -0.007435, 0.099024, 0.110363, -0.007435, -0.178390, -0.035509, -0.229083, 0.099024, -0.035509, 0.459127)"
    >;

	// —————————————————— 环境光PBR ——————————————————
	["环境光强度"]
	uniform mediump float envir_brightness
	<
		uigroup = "1 环境光"
		artist = "1" 
		min = "0.0" 
		max = "32.0" 
		init = "0.6"
	>;

	["环境光颜色"]
	uniform lowp float4 env_shadow_factor
	<
		uigroup = "1 环境光"
		artist = "0" 
		color = "1"
		// init = "(0.667,0.545,0.761,1.0)"
		init = "(1.0,1.0,1.0,1.0)"
	>;
	
	["反射边缘强度(envir_fresnel_brightness)"]
	uniform mediump float envir_fresnel_brightness
	<
		uigroup = "1 环境光"
		uistep = "0.001"
		min = "0.0" 
		max = "2.0" 
		init = "0.64"
		artist = "0"
	>;

	// 贴图
	["漫反射贴图"]
	uniform sampler Tex0 : DIFFUSE
	<
		artist = "1"
		mag = "linear"
		mip = "linear"
		min = "linear"
		lodbias = "-1.0"
	>;
	
	["金属度/sss/粗糙度"]
	uniform sampler SamplerRough
	<
		artist = "1"
		mag = "linear"
		mip = "linear"
		min = "linear"
		lodbias = "-1.0"
	>;

	["法线贴图(B通道存AO)"]
	uniform sampler SamplerNormalMap
	<
		artist = "1"
		mag = "linear"
		mip = "linear"
		min = "linear"
		lodbias = "-1.0"
	>;
	["cubemap贴图"]
	uniform sampler SamplerCubeMap
	<
		artist = "1"
		// addressu = "clamp"//2017-6-8修改：cube应该是左右连续的
		// addressv = "clamp"//2017-6-8新增：cube应该是左右连续的
		mag = "linear"
		min = "linear"
		mip = "linear"
		addressv = "clamp"
		addressu = "repeat"
		thumbnail = "0"
		path = "common\\textures\\envmap\\sh2_hdir.dds"
	>;
	["lightmap贴图"]
	uniform sampler TexLightmap : LIGHTMAP
	<
		artist = "1"
		mag = "LINEAR"
		mip = "LINEAR"
		min = "LINEAR"
		lodbias = "-0.5"
	>;
	["cloudscapes贴图"]
	uniform sampler CloudscapesMap
	<
		artist = "1"
		mag = "LINEAR"
		mip = "LINEAR"
		min = "LINEAR"
		lodbias = "-0.5"
		path = "scene_high\\model\\static\\5v5_marvel\\texture\\cloudscapes.png"
	>;
	["分开的alpha贴图"]
	uniform sampler sepAlphaTex: DIFFUSE_ALPHA
	<
	>;
	
	["自发光贴图"]
	uniform sampler EmissTex
	<
		artist = "1"
		mag = "LINEAR"
		mip = "LINEAR"
		min = "LINEAR"
		addressu = "clamp" 
		addressv = "clamp" 
		lodbias = "-0.5"
	>;

	["雾气纹理"]
	uniform sampler FogDetailTex
	<
		artist = "1"
		mag = "LINEAR"
		mip = "LINEAR"
		min = "LINEAR"
		lodbias = "-0.5"
		path = "shader\\core\\texture\\fog\\fog_detail.png"
	>;

	["力场图"]
	uniform sampler ForceFieldMap : FORCE_FIELD_MAP
	<
		artist = "0"
		mag = "linear"
		min = "linear"
		mip = "linear"
	>;

	["特效法线纹理"]
	uniform sampler FXNormalMap
	<
		artist = "1"
		mag = "linear"
		min = "linear"
		mip = "linear"
		path = "scene_high\\model\\static\\5v5_marvel\\texture\\glassnormal_nopack.png"
	>;

	["法线噪声贴图"]
	uniform sampler NormalNoiseMap
	<
		addressu = "repeat"
    	addressv = "repeat"
		artist = "1"
		mag = "linear"
		min = "linear"
		mip = "linear"
		path = "common\\textures\\fire_noise5.png"
	>;

	["反射图"]
	uniform sampler ReflectMap
	<
		artist = "1"
		mag = "linear"
		min = "linear"
		mip = "linear"
		path = "scene_high\\model\\static\\5v5_marvel\\texture\\space_image.png"
	>;

	["LUT映射图"]
	uniform sampler lutTex
	<
		artist = "0"
		mag = "nearest"
		min = "nearest"
		mip = "nearest"
		path = "common\\textures\\lutmap_nopack.png"
		addressv = "clamp"
		addressu = "clamp"
	>;

	// —————————————————— PBR调整 ——————————————————
	["金属度缩放"]
	uniform lowp float metal_multi
	<
		uigroup = "1 PBR"
		artist = "1" 
		init = "0.0"
		uistep = "0.001"
		min = "-1.0"
		max = "1.0"
	>;
	["粗糙度缩放"]
	uniform lowp float rough_multi
	<
		uigroup = "1 PBR"
		artist = "1" 
		init = "0.0"
		uistep = "0.001"
		min = "-1.0"
		max = "1.0"
	>;
	
	// ——————————————————自发光——————————————————
	
	["自发光强度"]
	uniform mediump float emissive_intensity
	<
		uigroup = "风格化"
		artist = "1" 
		uistep = "0.001"
		min = "1.0" 
		max = "10.0" 
		init = "1.0"
	>;
	// ——————————————————DIFFUSE——————————————————

	["漫反射强度"]
	uniform mediump float diffuse_intensity
	<
		init = "1.0"
		max = "5.0"
		min = "0.0"
		uistep = "0.001"
		artist = "0"
		uigroup = "0 漫反射"
	>;

	// ["自发光bloom强度"]
	// uniform mediump float emissive_bloom
	// <
	// 	uigroup = "bloom"
	// 	uistep = "0.001"
	// 	init = "0.0"
	// 	max = "5.0"
	// 	min = "0.0"
	// 	artist = "1"
	// >;

	// ["bloom强度"]
	// uniform mediump float illum_multi
	// <
	// 	uigroup = "bloom"
	// 	uistep = "0.001"
	// 	init = "1"
	// 	max = "10.0"
	// 	min = "0.0"
	// 	artist = "1"
	// >;

	// ["bloom阈值"]
	// uniform lowp float bloom_threshold
	// <
	// 	uigroup = "bloom"
	// 	uistep = "0.001"
	// 	init = "1.0"
	// 	max = "5.0"
	// 	min = "-1.0"
	// 	artist = "1"
	// >;
	// ["bloom范围"]
	// uniform lowp float bloom_range
	// <
	// 	uigroup = "bloom"
	// 	uistep = "0.001"
	// 	init = "0.0"
	// 	max = "1.0"
	// 	min = "-1.0"
	// 	artist = "1"
	// >;
	// ["是否开启Tonemapping"]
	// uniform lowp float u_tonemapping_factor
	// <
	// 	uigroup = "Tone"
	// 	min = "0.0"
	// 	max = "1.0"
	// 	init = "1.0"
	// 	artist = "1"
	// >;
	// ["Use ACES"]
	// uniform lowp float u_use_aces
	// <
	// 	uigroup = "Tone"
	// 	uistep = "0.001"
	// 	init = "1.0"
	// 	max = "1.0"
	// 	min = "0.0"
	// 	artist = "1"
	// >;
	// ["Tone Adapted Luminance"]
	// uniform lowp float u_adapted_lum
	// <
	// 	uigroup = "Tone"
	// 	uistep = "0.001"
	// 	init = "1.0"
	// 	max = "2.0"
	// 	min = "-1.0"
	// 	artist = "1"
	// >;

    ["场景亮度"]
    uniform lowp float scene_illum : SCENE_ILLUM
    <
		init = "1.0"
		artist = "0"    
    >; 
    
    uniform float max_dist_factor
    <
		init = "20.0"
    >;

    uniform mediump float act_factor
    <
		init = "0.0015"
    >;

    uniform float wind_factor
    <
		init = "0.00005"
    >;

 	["R染色强度"]
    uniform lowp float adjust_multi1
    <
		init = "0.3"
		uistep = "0.001"
		artist = "1"    
		max = "3.0"
		min = "0.0"
    >; 	

 	["G染色强度"]
    uniform lowp float adjust_multi2
    <
		init = "3"
		uistep = "0.001"
		artist = "1"    
		max = "3.0"
		min = "0.0"
    >; 	

 	["B染色强度"]
    uniform lowp float adjust_multi3
    <
		init = "0.64"
		uistep = "0.001"
		artist = "1"    
		max = "3.0"
		min = "0.0"
    >; 	

    ["R染色偏移"]
    uniform lowp float adjust_area1 
    <
		init = "0.0"
		uistep = "0.001"
		artist = "1"    
		max = "0.6"
		min = "-0.6"
    >; 

    ["G染色偏移"]
    uniform lowp float adjust_area2
    <
		init = "0.19"
		uistep = "0.001"
		artist = "1"    
		max = "0.6"
		min = "-0.6"
    >; 

    ["B染色偏移"]
    uniform lowp float adjust_area3
    <
		init = "0.01"
		uistep = "0.001"
		artist = "1"    
		max = "0.6"
		min = "-0.6"
    >; 
	
	["R变色颜色"]
	uniform mediump float4 changed_color1
	<
		//init = "(1.0, 0.4274, 0.3882, 1.0)" 
		init = "(0.145098,0.156863,0.211765,1.000000)" 

		artist = "1"
		color = "1"
	>;	
	["G变色颜色"]
	uniform mediump float4 changed_color2
	<
		//init = "(1.0, 0.4274, 0.3882, 1.0)" 
		init = "(0.1059,0.2588,0.3647,1)" 

		artist = "1"
		color = "1"
	>;	
	["B变色颜色"]
	uniform mediump float4 changed_color3
	<
		//init = "(1.0, 0.4274, 0.3882, 1.0)" 
		init = "(0.286275,0.462745,0.282353,1.000000)" 

		artist = "1"
		color = "1"
	>;

	["雾效修正"]
	uniform mediump float fog_fix
	<
		init = "0.0" 
		artist = "1"
	>;

	["_WaveSize"]
	uniform mediump float _WaveSize
	<
		init = "2"
		artist = "1"
		uigroup = "Wind"
	>;
	["_WindFrequency"]
	uniform mediump float _WindFrequency
	<
		init = "0.25"
		artist = "1"
		uigroup = "Wind"
	>;
	["_WindParam"]
	uniform mediump float4 _WindParam
	<
		init = "(0.2,0.2,0.2,0.35)"
		artist = "1"
		uigroup = "Wind"
	>;
	["BendIntensity"]
	uniform mediump float BendIntensity
	<
		init = "0.4"
		artist = "1"
		uigroup = "Wind"
	>;
	//流光特效
	["流光方向是否用3U"]
	uniform mediump float flowdir_thirduv
	<
		uigroup = "流光特效"
		uistep = "0.001"
		artist = "1"    
		max = "1.0"
		min = "0.0"
		init = "0.0"
	>;
	["流光间隔"]
	uniform mediump float sineFreq
	<
		uigroup = "流光特效"
		init = "3.0" 
		artist = "1"
	>;
	["流光宽度"]
	uniform mediump float sineBias
	<
		uigroup = "流光特效"
		init = "-0.2" 
		artist = "1"
		max = "1.0"
		min = "-1.0"
		uistep = "0.001"
	>;
	["流光速度"]
	uniform mediump float sineSpeed
	<
		uigroup = "流光特效"
		init = "2.0" 
		artist = "1"
	>;
	["流光过渡"]
	uniform mediump float sineSmoothness
	<
		uigroup = "流光特效"
		init = "3.0" 
		artist = "1"
	>;
	["流光亮度"]
	uniform mediump float emiss_intensity
	<
		uigroup = "流光特效"
		init = "16.0"
		artist = "1"
	>;

	// ["poisson uniform values"]
	// uniform lowp float4[8] poissonDisk
	// <
	// 	init = "(0.0, 0.0, -0.94201624, -0.39906216, 0.94558609, -0.76890725, -0.094184101, -0.92938870, 0.34495938, 0.29387760, -0.91588581, 0.45771432, -0.81544232, -0.87912464, -0.38277543, 0.27676845, 0.97484398, 0.75648379, 0.44323325, -0.97511554, 0.53742981, -0.47373420, -0.26496911, -0.41893023, 0.79197514, 0.19090188, -0.24188840, 0.99706507, -0.81409955, 0.91437590, 0.19984126, 0.78641367)"
	// >;
    ["高光亮度调节"]
	uniform lowp float specularAdjust
	<
		uigroup = "高光调节"
		init = "1.0" 
		uistep = "0.001"
		artist = "1"    
		max = "2.0"
		min = "0.0"	
	>;

	["环境亮度调节"]
	uniform lowp float envirAdjust
	<
		uigroup = "高光调节"
		init = "1.0" 
		uistep = "0.001"
		artist = "1"    
		max = "2.0"
		min = "0.0"	
	>;

	["diffuse亮度/对比度/对比度基准/饱和度"]
	uniform float4 diffuseFactor
	<
		uigroup = "高光调节"
		init = "(0.8, 0.8, 0.5, 1.2)"
		artist = "1"    
	>;

	["法线噪声密度"]
	uniform float2 normalNoiseDensity
	<
		uigroup = "法线噪声"
		init = "(160.0, 160.0)" 
		artist = "1"
	>;

	["法线噪声金属度相关/粗糙度相关"]
	uniform float4 normalNoiseFactor
	<
		uigroup = "法线噪声"
		init = "(0.0, 1.0, 1.0, 0.0)" 
		artist = "1"
	>;

	["法线噪声总强度"]
	uniform float normalNoiseIntensity
	<
		uigroup = "法线噪声"
		init = "0.05" 
		artist = "1"
	>;

	["金属度噪声总强度"]
	uniform float2 metalNoiseIntensity
	<
		uigroup = "法线噪声"
		init = "(0.05, 0.15)" 
		artist = "1"
	>;

	["粗糙噪声总强度"]
	uniform float2 roughNoiseIntensity
	<
		uigroup = "法线噪声"
		init = "(0.175, 0.29)" 
		artist = "1"
	>;
	["环境贴图旋转"]
	uniform mediump float env_rotation
	<
		init = "1.0"
		artist = "1"
		uigroup = "环境光"
		uistep = "0.001"
		max = "1.0"
		min = "-1.0"
	>;


	["LUT图方格边长/列数"]
	uniform float2 lutFactor
	<		
		// init = "(0.345, 0.518, 0.678,1.0)"
		// init = "(0.445, 0.678, 0.838,1.0)"
		init = "(8.0, 8.0)"
		artist = "1"
		uigroup = "LUT设置"
	>;
	
	["大龙系数"]
	uniform lowp float dawn_factor:DAWN_VALUE;
	["大龙出现"]
	uniform highp float boss_start:BOSS_START;
	["大龙消失"]
	uniform highp float boss_end:BOSS_END;

	macro(LIGHT_NUM)
	<
		cache = "0"
		default = "LIGHT_NUM_4"
	>;
	// attribute变量
	attribute float4 a_texcoord0 : TEXTURE0;
	attribute float4 a_texcoord1 : TEXTURE1; //uv2 for lightmap
	attribute float4 a_texcoord2 : TEXTURE2; //uv3

	attribute float4 texcoord4 : TEXTURE4;
	attribute float4 texcoord5 : TEXTURE5;
	attribute float4 texcoord6 : TEXTURE6;
	attribute float4 texcoord7 : TEXTURE7;

	attribute float4 a_color : DIFFUSE;
	attribute float4 a_position : POSITION;
	attribute float4 a_normal : NORMAL;
	attribute float4 a_tangent : TANGENT;
	["gpu蒙皮的索引"]
	attribute float4 a_blendindices: BLENDINDICES;
	["gpu蒙皮的权重"]
	attribute float4 a_blendweight: BLENDWEIGHT;

	
	// varying变量
	varying mediump float4 UV0;
	// varying mediump float2 UV3; // 贴花的uv
	varying mediump float4 v_lightmapuv;
	varying mediump float4 PosWorld;
	varying lowp float3 v_NormalWorld;
	varying highp float4 v_fog_info;
	varying highp float4 v_fol_color_nod;
	varying lowp float3 v_view_dir0;

	// uniform变量
	uniform highp float4x4 wvp : WORLD_VIEW_PROJECTION;
	uniform highp float4x4 world : WORLD;
	uniform highp float4x4 viewProj : VIEW_PROJECTION;
	
	uniform mediump float4x4 lightmapTrans : TEXTURE_TRANS1;
	
	uniform mediump float4 LightMapScale : LIGHT_MAP_SCALE;
	
	uniform mediump float4[LIGHT_ATTR_ITEM_NUM] DirLightAttr : DIR_LIGHT_ATTR;
	// uniform mediump float4[LIGHT_ATTR_ITEM_NUM] ShadowLightAttr : SHADOW_LIGHT_ATTR;
	// uniform mediump float4[LIGHT_ATTR_ITEM_TOTAL] PointLightAttrs : POINT_LIGHT_ATTR;

	uniform mediump float4 camera_pos : CAMERA_POSITION;
	
	uniform mediump float4x4 inverse_view : INV_VIEW;
	
	uniform mediump float4x4 view_mat : VIEW;
	
	
	uniform mediump float4 ZBufferParams: ZBUFFER_PARAMS;

	uniform float alphaRef : ALPHA_REF
	<
		init = "0.0"
	>;
	uniform float AlphaMtl : ALPHA_MTL
	<
		init = "1.0"
	>;
		// ——————————————————★★★ 顶点动画 ★★★—————————————————— 
	uniform highp float frame_time : FRAME_TIME;

	uniform lowp float4 wind_info : WIND_INFO;

	
	uniform highp float4x4 proj : PROJECTION;

	uniform lowp float4 u_fog_color : FOG_COLOR; // shader中用于调节lightmap的亮部
	uniform highp float4 u_fog_info : FOG_INFO; 

	["计算线性雾"]
	function get_fog_mix in (
	highp float fog_begin, // 雾的起始位置, view空间
	highp float fog_end, // 雾的结束位置, view空间
	highp float wvp_z // 顶点在投影空间的深度
	) out (mediump float fog_linear_factor) // 计算雾效因子
	{
		out(fog_linear_factor, saturate(smoothstep(fog_begin, fog_end, wvp_z)));
	};

	["计算高度雾"]
	function get_fog_height1 in(
	highp float fog_height_begin, // 雾的起始位置，世界空间
	highp float fog_height_end, // 雾的结束位置，世界空间
	highp float view_y // 顶点在世界空间的高度
	) out (mediump float fog_height_factor) // 计算雾效因子
	{
		highp float fromEnd = fog_height_end - view_y;
		mediump float delta = fog_height_end - fog_height_begin;
		mediump float height_factor = saturate( fromEnd / delta );
		
		out(fog_height_factor, height_factor);
		// out(fog_factor, 1.0f - height_factor);
		// out(fog_factor, max(linear_fog_factor, 1.0f - height_factor));
	};


	


	["计算河道mask"]
	function get_hedao_mask in (
	highp float2 st,
	highp float pct,
	highp float Width
	) out (mediump float hedao_mask) // 计算雾效因子
	{
		out(hedao_mask,smoothstep(pct-Width, pct, st.y) - smoothstep(pct, pct+Width, st.y));
	};

	function SmoothCurve in(float4 x) out(highp float4 x_out){
		highp float4 smooth_curve = x * x * (float4(3.0f) - 2.0f * x);
		out(x_out,smooth_curve);
	};
	function TriangleWave in(float4 x) out(highp float4 x_out){
		highp float4 triangle_wave = abs(fractional(x + float4(0.5f)) * 2.0f - float4(1.0f));
		out(x_out,triangle_wave);
	};
	function SmoothTriangleWave in(float4 x) out(highp float4 x_out){
		function TriangleWave(x) out(float4 x_tri);
		function SmoothCurve(x_tri) out(float4 x_smoothcurve);
		out(x_out,x_smoothcurve);
	};
	["树木顶点动画"]
	function AnimateVertex in(float4 worldpos, float3 normal, float4 animParams, float variation,float wavesize,float windfrequency,float4 windparam,float bendintensity,float time) out(float4 animate_pos)
	{	
		// animParams.r = branch phase
		// animParams.g = edge flutter factor
		// animParams.b = primary factor
		// animParams.a = secondary factor

		//	based on original wind bending
		float fDetailAmp = 0.1f;
		float fBranchAmp = 0.3f;

		//	Phases (object, vertex, branch)
		float fObjPhase = fractional( (worldpos.x + worldpos.z) * wavesize ) + variation;
		float fBranchPhase = fObjPhase + animParams.r; //---> fObjPhase + vertex color red
		float fVtxPhase = dot(worldpos.xyz, float3(animParams.g + fBranchPhase)); // controled by vertex color green

		float timeoffset = dot(worldpos.xyz, windparam.xyz);
		//	Animate Wind
		float sinuswave = (time * 3.0f + timeoffset) * windfrequency + variation;
		float4 triwave = float4(fractional(worldpos.x * wavesize) + sinuswave, fractional(worldpos.z * wavesize) + sinuswave * 0.8f, 0.0f, 0.0f);
		function SmoothTriangleWave(triwave) out(highp float4 TriangleWaves);
		float Oscillation_ = TriangleWaves.x + (TriangleWaves.y * TriangleWaves.y);
		float Oscillation = (Oscillation_ + 3.0f) * 0.33f * windparam.w;

		//	x is used for edges; y is used for branches float2(_Time.y, _Time.z) // 0.193
		float2 vWavesIn = float2(time) + float2(timeoffset) + float2(fVtxPhase, fBranchPhase);
		//float2 vWavesIn = _TimeFrequency.y + float2(fVtxPhase, fBranchPhase);

		highp float4 vWaves = fractional(float4(vWavesIn.x,vWavesIn.x,vWavesIn.y,vWavesIn.y) * float4(1.975f, 0.793f, 0.375f, 0.193f)) * 2.0f - float4(1.0f);
		//float4 vWaves = (frac( vWavesIn.xxyy * float4(1.975, 0.793, lerp(float2(0.375, 0.193), _TimeFrequency.zw, _LeafTurbulence )) ) * 2.0 - 1.0);
		function SmoothTriangleWave(vWaves) out(highp float4 vWaves_tri);
		highp float2 vWavesSum = vWaves_tri.xz + vWaves_tri.yw;

		//	Edge (xz) controlled by vertex green and branch bending (y) controled by vertex alpha
		float3 bend_xyz = animParams.g * fDetailAmp * normal.xyz * sign(normal.xyz); // sign important to match normals of both faces!!! otherwise edge fluttering might be corrupted.
		float bend_y = animParams.a * fBranchAmp;
		float3 bend = float3(bend_xyz.x,bend_y,bend_xyz.z);

		//	Secondary bending
		highp float3 worldpos0 = worldpos.xyz + ((float3(vWavesSum.xy,vWavesSum.x) * bend * bendintensity) + (windparam.xyz * vWavesSum.y * animParams.a)) * Oscillation;

		//	Preserve Length / would need single game objects...
		//	pos.xyz = normalize(pos.xyz) * origLength;

		//	Primary bending / Displace position
		highp float3 worldpos1 = worldpos0 + animParams.b * windparam.xyz * Oscillation;

		out(animate_pos,float4(worldpos1,1.0f));
	};

	["LUT采样"]
	function Lut in(float3 color, sampler lutmap, float2 lut_factor) out(lowp float3 colorOut)
	{
		float3 color01 = saturate(color);
		float column = 8.0f;
		float pice = 7.0f;
		float row = 1.0f;
		float2 fenmu = float2(column, row) * column;
		float3 picColor = color01 * pice;
		float3 floorPicColor = floor(picColor);
		float3 ceilPicColor = ceil(picColor);

        float2 UVRG0 = (floorPicColor.rg + float2(0.5f)) / fenmu;
        float2 UVRG1 = (ceilPicColor.rg + float2(0.5f)) / fenmu;

		float2 UVRGB0 = float2(UVRG0.r + floorPicColor.b / column, UVRG0.g);
		float2 UVRGB1 = float2(UVRG1.r + ceilPicColor.b / column, UVRG1.g);
        float3 RGBLerp = picColor - floorPicColor;

        float3 colorOut01 = sample(lutmap, UVRGB0).rgb;
        float3 colorOut02 = sample(lutmap, UVRGB1).rgb;
        out(colorOut, lerp(colorOut01, colorOut02, RGBLerp));
	};

	function Tonemap_Uchimura_Base in(float3 x, float Exposed, float P, float a, float m, float l, float c, float b) out(float3 toneColor)
	{
		float3 color = x*Exposed;
	    // Uchimura 2017, "HDR theory and practice"
	    // Math: https://www.desmos.com/calculator/gslcdxvipg
	    // Source: https://www.slideshare.net/nikuque/hdr-theory-and-practicce-jp
	    float l0 = ((P - m) * l) / a;
	    float S0 = m + l0;
	    float S1 = m + a * l0;
	    float C2 = (a * P) / (P - S1);
	    float CP = -C2 / P;

	    float3 w0 = float3(1.0f) - smoothstep(float3(0.0f), float3(m), color);
	    float3 w2 = step(float3(m + l0), color);
	    float3 w1 = float3(1.0f) - w0 - w2;

	    float3 T = m * pow(color / float3(m), float3(c)) + float3(b);
	    float3 S = float3(P) - (P - S1) * exp(CP * (color - float3(S0)));
	    float3 L = float3(m) + a * (color - float3(m));
	    float3 tonecolor = (T * w0 + L * w1 + S * w2);
	    float3 tonecolor_gamma = pow(tonecolor,float3(1.0f/2.2f));
	    out(toneColor, tonecolor_gamma);
	};

	function Tonemap_Uchimura in (float3 x, float Exposed)  out(float3 toneColor)
	{
	    float P = 1.0f;  // max display brightness
	    float a = 1.0f;  // contrast
	    float m = 0.22f; // linear section start
	    float l = 0.4f;  // linear section length
	    float c = 1.0f; // black
	    float b = 0.0f;  // pedestal
	    function Tonemap_Uchimura_Base(x, Exposed, P, a, m, l, c, b) out(float3 toneColor1);
	    out(toneColor, toneColor1);
	};

	vertex
	{
		highp float4 position = a_position;
		highp float4 normal = a_normal;

		// macro(TRANS_ENABLE) out(highp float4 normal) 
		// {
		// 	branch ("0") 
		// 	{
		// 		out(normal, a_normal);
		// 	}
		// 	branch ("1") 
		// 	{
		// 		out(normal, a_normal * float4(1.0f, -1.0f, 1.0f, 1.0f));
		// 	}
		// };

		// 世界空间坐标
		// macro(EDITOR) out(mediump float4 pos_world){
		// 	branch("1")
		// 	{
		// 		out(pos_world, transform(position, world));
		// 	}
		// 	branch("0"){
		// 		macro(INSTANCE_TYPE) out(mediump float4 _pos_world)
		// 		{
		// 		    branch("INSTANCE_TYPE_PRS")
		// 		    {
		// 				float4x4 instWorldMat = float4x4(float4(texcoord5.x, texcoord6.x, texcoord7.x, 0.0f),
		// 										     float4(texcoord5.y, texcoord6.y, texcoord7.y, 0.0f),
		// 										     float4(texcoord5.z, texcoord6.z, texcoord7.z, 0.0f),
		// 										     float4(texcoord5.w, texcoord6.w, texcoord7.w, 1.0f));
		// 				float4 world_pos = transform(position, instWorldMat);

		// 		    	macro(TRANS_ENABLE) out(float4 trans_world_pos){
		// 					branch("1") {
		// 						out(trans_world_pos, float4(world_pos.x, -world_pos.y, world_pos.z, world_pos.w));
		// 					}
		// 					branch("0") {
		// 						out(trans_world_pos, world_pos);
		// 					}
		// 				};
		// 				out(_pos_world, trans_world_pos);
		// 		    }
				    
		// 		    branch("INSTANCE_TYPE_PRS_LM")
		// 		    {
		// 				mediump float4x4 instWorldMat = float4x4(float4(texcoord5.x, texcoord6.x, texcoord7.x, 0.0f),
		// 										     float4(texcoord5.y, texcoord6.y, texcoord7.y, 0.0f),
		// 										     float4(texcoord5.z, texcoord6.z, texcoord7.z, 0.0f),
		// 										     float4(texcoord5.w, texcoord6.w, texcoord7.w, 1.0f));
		// 				mediump float4 world_pos = transform(position, instWorldMat);
						
		// 		    	macro(TRANS_ENABLE) out(mediump float4 trans_world_pos){
		// 					branch("1") {
		// 						out(trans_world_pos, float4(world_pos.x, -world_pos.y, world_pos.z, world_pos.w));
		// 					}
		// 					branch("0") {
		// 						out(trans_world_pos, world_pos);
		// 					}
		// 				};
		// 				out(_pos_world, trans_world_pos);
		// 		    }

		// 		    branch("INSTANCE_TYPE_NONE")
		// 		    {
		// 		    	// 未合批的在引擎中已经转了world了
		// 		    	out(_pos_world, transform(position, world));
		// 		    }
		// 		};
		// 		out(pos_world,  _pos_world);
		// 	}
		// };

		highp float4 pos_world = transform(position, world);
		// 顶点动画，在世界空间坐标下计算
		macro(ANIME_ENABLE) out(highp float4 anim_pos1) {
			branch ("1") {
				   macro(TRANS_ENABLE) out(lowp float trans_sign){
					branch("1") {
						out(trans_sign, -1.0f);
					}
					branch("0") {
						out(trans_sign, 1.0f);
						}
					};
			
			    highp float dt = sin(2.0f * frame_time);
				// 自然风的方向
				mediump float2 wind_dir = float2(-1.0f, -1.0f);
				// 自然风的力,与角色互动无关
				mediump float2 wind_power = float2(dt) * wind_factor * wind_dir;

				highp float2 react_dir = pos_world.xz - wind_info.xy;
				mediump float dist = length(react_dir); 
				lowp float dist_factor = saturate((max_dist_factor - dist) / max_dist_factor);// 距离角色的距离
				mediump float h = trans_sign * pos_world.y;
				mediump float2 h_offset = h * h * h * (act_factor * dist_factor * wind_info.zw + wind_power);
				mediump float y = sqrt(h * h - h_offset.x * h_offset.x - h_offset.y * h_offset.y) * sign(h);
				out(anim_pos1, float4(pos_world.x + h_offset.x, trans_sign * y, pos_world.z + h_offset.y, pos_world.w));
			}
			branch ("0"){
				out(anim_pos1, pos_world);
			}
		};
		// 草丛是否使用力场扰动
		macro(FORCE_FIELD_ENABLE) out(highp float4 anim_pos) {
			branch ("1") {
				macro(TRANS_ENABLE) out(lowp float trans_sign){
					branch("1") {
						out(trans_sign, -1.0f);
					}
					branch("0") {
						out(trans_sign, 1.0f);
					}
				};
				mediump float4x4 instWorldMat1 = float4x4(float4(texcoord5.x, texcoord6.x, texcoord7.x, 0.0f),
												     float4(texcoord5.y, texcoord6.y, texcoord7.y, 0.0f),
												     float4(texcoord5.z, texcoord6.z, texcoord7.z, 0.0f),
												     float4(texcoord5.w, texcoord6.w, texcoord7.w, 1.0f));
				mediump float4 core_pos = transform(float4(a_tangent.xyz, 1.0f), instWorldMat1);
				// 不能用scene_size,1280.0f是和force_field_radial里面的对应的  
				macro(NEOX_METAL) out(highp float2 force_uv) {
					branch("1") {
						out(force_uv, float2(core_pos.x / 1280.0f + 0.5f, -core_pos.z / 1280.0f + 0.5f));
					}
					branch("0") {
						out(force_uv, float2(core_pos.x / 1280.0f + 0.5f, core_pos.z / 1280.0f + 0.5f));
					}
				};
				highp float4 force_color = sample(ForceFieldMap, force_uv);

				lowp float2 force = float2(force_color.x - force_color.y, force_color.z - force_color.w);
				// lowp float2 force = float2(force_color.x, 0.0f);
	
				mediump float h = anim_pos1.y;
				highp float dt = sin(2.0f * frame_time);
				mediump float2 wind_dir = float2(-1.0f, -1.0f);
				mediump float2 wind_power = float2(dt) * wind_dir;

				// mediump float2 h_offset = h * h * (force * 0.003f + wind_power * 0.003f);
				mediump float2 h_offset = h * h * (force * 0.3f + wind_power * 0.003f);

				mediump float ori_length = length(anim_pos1.xyz - core_pos.xyz);
				mediump float2 pos_xz = anim_pos1.xz + h_offset.xy - core_pos.xz;
				mediump float xz_length = length(pos_xz);

				// 这句计算可理解为 x*x + y*y+z*z = ori_length * ori_length 保证的长度一致
				mediump float y = sqrt(max(ori_length * ori_length - xz_length * xz_length, 0.1f));
				mediump float max_length = min(ori_length, xz_length);
				mediump float xz_length_no_zero = max(xz_length, 0.1f);
				mediump float pos_x = pos_xz.x / xz_length_no_zero * max_length;
				mediump float pos_z = pos_xz.y / xz_length_no_zero * max_length;

				out(anim_pos, float4(pos_x + core_pos.x, trans_sign * y, pos_z + core_pos.z, anim_pos1.w));
			}
			branch ("0"){
				out(anim_pos, anim_pos1);
			}
		};

		highp float4 posworld_ = anim_pos;
		out(PosWorld,posworld_);

		// float3x3 worldMat = float3x3(world);
		// highp float3 world_normal = float3(normalize(transform(normal.xyz, worldMat)));
		// out(v_NormalWorld, world_normal);


		macro(TRANS_ENABLE) out(highp float3 world_normal, highp float3x3 worldMat)
		{
			branch("1")
			{
				highp float3x3 worldMat1 = float3x3(
					float3(world[0][0], -world[0][1], world[0][2]),
					float3(world[1][0], -world[1][1], world[1][2]),
					float3(world[2][0], -world[2][1], world[2][2])
					);
				out(world_normal,float3(normalize(transform(normal.xyz, worldMat1))));
				out(worldMat, worldMat1);
				
			}
			branch("0")
			{
				highp float3x3 worldMat0 = float3x3(world);
				out(world_normal,float3(normalize(transform(normal.xyz, worldMat0))));
				out(worldMat, worldMat0);
			}	
		};
		out(v_NormalWorld, world_normal);

		out(UV0, float4(a_texcoord0.xy, 0.0f, 0.0f));
		/*
		macro(USE_FLOWEMISS_VFX)
		{
			branch("1")
			{
				out(UV3, a_texcoord2.xy);
			}
			branch("0")
			{
				
			}	
		};	
		*/

		macro(FX_ENABLE) out(highp float4 mdl_pos_world){
			branch("1")
			{
				mediump float sphere_distance = length((float3(-165.0f, 0.0f, 165.0f) - posworld_.xyz) * 0.1f);
				mediump float2 world_uv = ((float2(posworld_.x, posworld_.z) * 0.002f) + float2(1.0f)) * 0.5f;
				//出现半径
				//mediump float appear_editor = (boss_start + u_fog_info.x) * 0.000002f;
				mediump float appear_editor = boss_start;
				//mediump float appear_factor = ((-0.2f + (appear_editor - 0.0f) * (1.0f - -0.2f) / (1.0f - 0.0f)));
				mediump float appear_factor = appear_editor * 1.2f - 0.2f;
				mediump float appear_radius = 100.0f * appear_factor;

				lowp float pattern_mask = saturate(fractional(sin(dot(world_uv, float2(12.9898f,78.2333f))) * 43758.5453123f)) * 2.0f;

				lowp float sphere_mask = 1.0f - ((sphere_distance - appear_radius) / -3.5f) - pattern_mask;
				//mediump float edge_factor = smoothstep(1.0f,0.0f,abs(sphere_mask - 1.0f) / 0.24f);
				lowp float edge_factor = saturate(1.0f - abs(sphere_mask - 1.0f) * 4.0f);
				//mediump float edge_mask = saturate(pow(edge_factor , 2.0f));
				lowp float edge_mask = edge_factor * edge_factor;
				function get_hedao_mask(world_uv , 1.0f - world_uv.x , -0.25f) out(float hedaoMask_);
				lowp float HedaoMask = smoothstep(0.0f , 0.5f , saturate(hedaoMask_));
				mediump float EdgeMask = edge_mask * HedaoMask;

				highp float3 mdl_pos_world_ = anim_pos.xyz + world_normal * float3(5.0f * EdgeMask) * smoothstep(0.5f,1.0f,posworld_.y);
				out(mdl_pos_world,float4(mdl_pos_world_,1.0f));
			}
			branch("0")
			{
				out(mdl_pos_world,float4(anim_pos.xyz,1.0f));
			}
		};

		macro(WIND_ON) out(highp float4 wind_pos_world)
		{
			branch("1")
			{
				lowp float4 bendingCoords = float4(a_color.rgb,a_color.b); 
				float variation = 1.0f;
				function AnimateVertex(mdl_pos_world, world_normal, bendingCoords, variation,_WaveSize,_WindFrequency,_WindParam,BendIntensity,frame_time) out(highp float4 wind_pos_world_);
				out(wind_pos_world,wind_pos_world_);
			}
			branch("0")
			{
				out(wind_pos_world,mdl_pos_world);
			}
		};
		// 计算顶点位置
		highp float4 screen_pos = transform(wind_pos_world, viewProj);
		vertex(screen_pos);

		mediump float3 tangentWorld = float3(normalize(a_tangent.xyz * worldMat));
		highp float tan_coef = 1.0f - 2.0f * step(1.5f, length(a_tangent.xyz));
		mediump float3 binormal_world = cross(tangentWorld, world_normal) * tan_coef;

		macro(LIGHT_MAP_ENABLE) out(mediump float2 lightmapuv)
		{
			branch("1") {
				macro(EDITOR) out(mediump float4 tmp_texture_1)
				{
					branch("1"){
						out(tmp_texture_1, transform(float4(a_texcoord1.xy, 1.0f, 0.0f), lightmapTrans));
					}
					branch("0"){
						macro(INSTANCE_TYPE) out(mediump float4 _tmp_texture_1)
						{
						    branch("INSTANCE_TYPE_PRS_LM")
						    {
								float4x4 instLightmapTrans = float4x4(float4(texcoord4.x, 0.0f, 0.0f, 0.0f),
																      float4(0.0f, texcoord4.y, 0.0f, 0.0f),
																      float4(texcoord4.z, texcoord4.w, 1.0f, 0.0f),
																      float4(0.0f, 0.0f, 0.0f, 1.0f));
								out(_tmp_texture_1, transform(float4(a_texcoord1.xy, 1.0f, 0.0f), instLightmapTrans));
						    }
						   
						    branch("INSTANCE_TYPE_NONE")
						    {
								out(_tmp_texture_1, transform(float4(a_texcoord1.xy, 1.0f, 0.0f), lightmapTrans));
						    }
						    branch("INSTANCE_TYPE_PRS")
						    {
								out(_tmp_texture_1, transform(float4(a_texcoord1.xy, 1.0f, 0.0f), lightmapTrans));
						    }
						};
						out(tmp_texture_1, _tmp_texture_1);
					}
				};
				out(lightmapuv, tmp_texture_1.xy);
			}
			branch("0") {
				out(lightmapuv, float2(0.0f, 0.0f));
			}
		};

		macro(TRANS_ENABLE) out(mediump float height) {
			branch ("1") {
				out(height, -pos_world.y);
			}
			branch ("0") {
				out(height, pos_world.y);
			}
		};
		function get_fog_height1(u_fog_info.z, u_fog_info.w, height) out(mediump float fog_height_factor1);

		macro(SYSTEM_DEPTH_RANGE_NEGATIVE) out(mediump float fog_distance1)
		{
			branch("1")
			{
				["GL渲染系统下"]
				// out(fog_distance1, final_position.z * 2.0f - 1.0f);
				out(fog_distance1, screen_pos.w * ((screen_pos.z/screen_pos.w) *0.5f + 0.5f));
			}
			branch("0")
			{
				["Dx和Metal渲染系统下"]
				out(fog_distance1, screen_pos.z);
			}
		};
		float2 fog_detail_tilling = float2(0.006f);
		float2 fog_detail_speed = float2(0.2f,0.0f);
		float2 fog_uv = (pos_world.xz + pos_world.yy) * fog_detail_tilling + fog_detail_speed * frame_time;
		out(v_fog_info, float4(fog_uv,fog_distance1, 1.0f - fog_height_factor1));

		highp float fog_uniform = 0.000002f;
		mediump float fog_start = 330.0f + fog_fix + dawn_factor * 20.0f + u_fog_info.x * fog_uniform * 200.0f;
		mediump float fog_end = 730.0f + fog_fix + dawn_factor * 10.0f + u_fog_info.x * fog_uniform * 200.0f;
		function get_fog_mix(fog_start, fog_end, fog_distance1) out(mediump float fog_linear_factor);
	
		// 对fol进行模拟
		out(v_fol_color_nod, lerp(float4(0.364f, 0.572f, 0.705f, 0.0f),float4(0.484f, 0.624f, 0.819f, 1.0f), float4(fog_linear_factor)));
		lowp float3 view_dir0 = normalize(camera_pos.xyz - posworld_.xyz);
		macro(TRANS_ENABLE) out(lowp float3 view_dir)
		{
			branch ("0") 
			{
				out(view_dir, view_dir0);
			}
			branch ("1") 
			{
				out(view_dir, -view_dir0);
			}
		};
		out(v_view_dir0, view_dir);

		macro(TWOGROUP_ENABLE) out(lowp float v_cl_changed_sig1) {
			branch ("1") {
				lowp float signal = saturate((pos_world.x + pos_world.z+90.0f)/180.0f);
				out(v_cl_changed_sig1, signal);
			}
			branch ("0") {
				out(v_cl_changed_sig1, 0.0f);
			}
		};
		lowp float emissive_multi = 4.0f + sin(3.0f * frame_time);
		out(v_lightmapuv, float4(lightmapuv.x, lightmapuv.y, v_cl_changed_sig1, emissive_multi));
	}


	pixel
	{

		// ——————————————————★★★ 基础设置 ★★★——————————————————	
		// 采样贴图
		lowp float4 diffuse_map_color_ = sample(Tex0, UV0.xy);

		macro(DIFFUSE_ALPHA_SEPARATE) out(lowp float4 diffuse_map_color)
		{
			branch("1")
			{
				lowp float4 separateColor = sample(sepAlphaTex, UV0.xy);
				out(diffuse_map_color, float4(diffuse_map_color_.xyz, separateColor.w));
			}
			branch("0") {
				out(diffuse_map_color, diffuse_map_color_);
			}
		};

		macro(OCCLUSION_ENABLE) out(lowp float occlusion, lowp float metal, lowp float rough, lowp float2 sample_norm){
			branch ("1")
	    	{
				lowp float4 pbr_map = sample(SamplerRough, UV0.xy);
				out(metal, saturate(pbr_map.r + metal_multi));
				out(rough, saturate(pbr_map.b + rough_multi));
				lowp float4 norm_ = sample(SamplerNormalMap, UV0.xy);
				out(sample_norm, norm_.xy);
				out(occlusion, norm_.z);
			}
			branch ("0")
	    	{
				lowp float4 norm_ = sample(SamplerNormalMap, UV0.xy);
				out(metal, diffuse_map_color.a);
				out(rough, norm_.z);
				out(sample_norm, norm_.xy);
				out(occlusion, 1.0f);
			}
		};

		mediump float2 fog_uv = v_fog_info.xy;
		mediump float fog_distance = v_fog_info.z;
		mediump float fog_height_factor = v_fog_info.w;
		// —————————————————— 法线 ——————————————————	
		lowp float3 vertex_normal_world = v_NormalWorld;
		// 区域分色
		lowp float area_factor = v_lightmapuv.z;

		lowp float2 normOff_ = (sample_norm * 2.0f - float2(1.0f));
		lowp float3 normalWorld_inner = normalize(float3(normOff_.x, 1.0f, normOff_.y));
		lowp float3 normalWorld = normalWorld_inner;
		
		macro(LIGHT_MAP_ENABLE) out(mediump float3 lightmap_color,mediump float shadow_mask)
		{
		    branch("1") {
				lowp float4 _lightmap_color = sample(TexLightmap, v_lightmapuv.xy);
				lowp float3 light_map_color_gamma = _lightmap_color.xyz * LightMapScale.yzw;
				lowp float light_map_lumin = dot(light_map_color_gamma,float3(0.3f,0.59f,0.11f));
				lowp float3 light_map_color_adjust = lerp(light_map_color_gamma,u_fog_color.rgb * light_map_lumin,float3(_lightmap_color.w));
				out(lightmap_color, light_map_color_adjust);
				out(shadow_mask,1.0f - _lightmap_color.a);
		    }
		    branch("0") {
				out(lightmap_color, float3(0.0f));
				out(shadow_mask,1.0f);
		    }
		};
		

		// ——————————————————★★★ 光照设置 ★★★——————————————————
		//平行光颜色
		lowp float4 gi_color = DirLightAttr[1]; 
		// 光源方向
		mediump float4 light_dir = DirLightAttr[3];

		lowp float3 light_dir_ndl = light_dir.xyz;

		mediump float4 posworld = PosWorld;
		// ——————————————————★★★ 常用参数 ★★★——————————————————

		lowp float roughness = rough;
				
		lowp float non_metal = 1.0f - metal;

		// 视线方向

		lowp float3 view_dir = normalize(v_view_dir0);

		lowp float3 H = normalize(view_dir - light_dir_ndl);
		mediump float VoH = dot(view_dir, H);
		mediump float VoL = dot(view_dir, -light_dir_ndl);
		mediump float NoV = dot(view_dir, normalWorld);
		mediump float NoH = dot(normalWorld, H);

		// NdotL
		mediump float NoL = dot(normalWorld, -light_dir_ndl);

		// 计算OrenNayarLighting因子
		lowp float ggx_rough = lerp(0.04f, 1.0f, rough);

		macro(ORENNAYAR_ENABLE) out(lowp float orennayar_factor) {
			branch ("0") {
				out(orennayar_factor,1.0f);
			}
			branch ("1") {
				float a = ggx_rough * ggx_rough;
		        float s = a;// / ( 1.29 + 0.5 * a );
				float s2 = s * s;
		        float VoL1 = 2.0f * VoH * VoH - 1.0f;		// double angle identity
				float Cosri = VoL1 - NoV * NoL;
				float C1 = 1.0f - 0.5f * s2 / (s2 + 0.33f);
				condition(Cosri) out(float C3) {
					branch ("%0% >= 0.0") {
						out(C3, min(1.0f,NoL/max(0.01f, NoV)));
					}
					default {
						out(C3, 1.0f);
					}
				};
				float C2 = 0.45f * s2 / (s2 + 0.09f) * Cosri * C3;
				out(orennayar_factor, clamp(( C1 + C2 ) * ( 1.0f + ggx_rough * 0.5f), 0.0f, 5.0f));
			}
		};

		mediump float NdotL_spec = min(NoL,shadow_mask);
		lowp float NdotL_diff = NdotL_spec * orennayar_factor;

		// ——————————————————★★★ DIFFUSE ★★★—————————————————— 
		mediump float3 diffuse_color = diffuse_map_color.xyz * diffuse_map_color.xyz * diffuse_intensity; 
			
		// 金属度计算过后的漫反射光强
		mediump float3 non_metal_diffuse = non_metal * diffuse_color; 

		// AO
	
		// 有lightmap就不要SH了
		function calc_env_sh( envSHR, envSHG, envSHB, normalWorld) out (mediump float3 ibl_diffuse1);
		mediump float3 ibl_diffuse = ibl_diffuse1; //环境光的sh与高光比为3:130;

		// 环境光调整色计算
		lowp float3 env_factor_color = u_fog_color.rgb + NdotL_diff * gi_color.xyz * 0.5f; 

		// Final Diffuse
		// 固有色 * (主光源 + 环境光 + 天光) + 补光
		mediump float3 final_diffuse = non_metal_diffuse * (NdotL_diff * gi_color.xyz + lightmap_color + ibl_diffuse * shadow_mask);

		// —————————————————— ★★★ SPECULAR ★★★—————————————————— 
		mediump float3 spec_color = lerp(diffuse_color.xyz, float3(0.04f), float3(non_metal)); 

		// F
		lowp float Fc = exp2(-8.302f * VoH);
		lowp float3 F = spec_color + (float3(1.0f) - spec_color) * Fc;

		// D 
		function D_GGX(ggx_rough, NoH) out(lowp float D);
		
		// G
		function G_Schlick_Disney(ggx_rough, NoV, NdotL_spec) out (lowp float G);

		mediump float3 final_specular = (G * D * NdotL_spec * specularAdjust) * F * gi_color.xyz;

		// ——————————————————★★★ IBL ★★★—————————————————— 
		mediump float3 R_rotated = reflect(-view_dir, normalWorld);
		function GetEnvirmentColor_panorama (SamplerCubeMap, roughness, R_rotated, 130.0f) out (mediump float3 envir); // 环境光最大强度不改了，再改是猪！
		function EnvBRDFApprox(spec_color, ggx_rough, NoV, oneminus(NdotL_spec * 0.8f) * envir_fresnel_brightness) out (mediump float3 env_brdf);
		float3 final_envir = env_brdf * envir * env_factor_color * envir_brightness * envirAdjust;

		/////////////////////////////////////////////////////////////////
		// ——————————————————★★★ 最终光照计算 ★★★——————————————————
		
		mediump float3 result_diff_raw =  final_diffuse + final_specular + final_envir;
		lowp float4 encode_color_1 = float4(sqrt(result_diff_raw),1.0f);
		lowp float3 fx_color = encode_color_1.xyz;

		["黄昏染色"]
		lowp float emissive_mask = oneminus(saturate(fx_color.g + 0.8f));
		lowp float fusion_dawn_factor = emissive_mask * v_lightmapuv.w * dawn_factor;
		lowp float3 dawn_color = lerp(fx_color.rgb * lerp(1.0f,0.863f,dawn_factor), float3(0.7f, 0.35f, 0.16f), float3(fusion_dawn_factor));

		mediump float4 cloud = sample(FogDetailTex, fog_uv);
		float fog_combined_lerp = saturate(v_fol_color_nod.a + cloud.r * v_fol_color_nod.a) * u_fog_color.a * 0.75f;
		mediump float3 fog_combined_0 = lerp(dawn_color.rgb, v_fol_color_nod.rgb, float3(fog_combined_lerp));

		macro(LUT_ENABLE) out(lowp float3 fog_combined_) 
		{
			branch ("1") 
			{
                function Lut(fog_combined_0, lutTex, lutFactor) out(lowp float3 lutedColor00);
				out(fog_combined_, lutedColor00);
			}
			branch ("0") 
			{
				out(fog_combined_, fog_combined_0);
			}
		};

		mediump float3 changetone1 = lerp(float3(1.0f) ,float3(0.627f, 0.745f, 1.0f),float3(area_factor));
		mediump float3 changetone = lerp(changetone1, float3(0.814f, 0.7239f, 0.6039f), float3(dawn_factor));
		mediump float illum = dot(fog_combined_ * changetone1, float3(0.3f, 0.59f, 0.11f));
		mediump float illum_fix2 = lerp(1.095f, 0.894f,illum);
		mediump float illum_fix = lerp(lerp(1.0f, illum_fix2, area_factor),1.0f,dawn_factor);
		mediump float3 fog_combined_color = fog_combined_ * changetone * illum_fix;

 		mediump float3 color_export = fog_combined_color * scene_illum;

		mediump float4 output_color = float4(color_export,encode_color_1.a);
		pixel(output_color);
	}
}

